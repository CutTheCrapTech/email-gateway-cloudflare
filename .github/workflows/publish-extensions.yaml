# .github/workflows/publish-extensions.yml
name: Publish Browser Extensions

on:
  workflow_dispatch:
    inputs:
      package_name:
        description: "The scoped name of the extensions package to publish (e.g., '@email-gateway/email-alias-extensions'). Found in the package's package.json or from previous GitHub Release tags."
        required: true
        type: string
  workflow_call:
    inputs:
      published_packages:
        description: "JSON array of published packages from changesets/action"
        required: true
        type: string
    secrets:
      CHROME_CLIENT_ID:
        required: true
      CHROME_CLIENT_SECRET:
        required: true
      CHROME_REFRESH_TOKEN:
        required: true
      FIREFOX_API_KEY:
        required: true
      FIREFOX_API_SECRET:
        required: true

jobs:
  publish-extensions:
    runs-on: ubuntu-latest
    permissions:
      contents: read # To checkout the repo and read releases
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      - name: Install pnpm
        uses: pnpm/action-setup@a7487c7e89a18df4991f7f222e4898a00d66ddda # v4.1.0
        with:
          version: 10

      - name: Set up Node.js
        uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # v4.4.0
        with:
          node-version: "lts/*"
          cache: "pnpm"

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Determine Packages to Publish
        id: packages_to_publish
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PACKAGES_JSON="[]"
          # Manual workflow_dispatch run
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            PACKAGE_NAME="${{ inputs.package_name }}"
            echo "Manual run for package: $PACKAGE_NAME"
            LATEST_VERSION=$(gh release list --repo $GITHUB_REPOSITORY --limit 1 --json tagName --jq ".[] | select(.tagName | startswith(\"$PACKAGE_NAME@\")) | .tagName" | sed "s#$PACKAGE_NAME@##")
            if [ -z "$LATEST_VERSION" ]; then
              echo "::error::Could not find any releases for package $PACKAGE_NAME."
              exit 1
            fi
            echo "Found latest version: $LATEST_VERSION"
            PACKAGES_JSON=$(jq -n --arg name "$PACKAGE_NAME" --arg version "$LATEST_VERSION" '[{"name": $name, "version": $version}]')
          # Automated workflow_call run
          else
            echo "Automated run from published packages."
            PACKAGES_JSON='${{ inputs.published_packages }}'
          fi
          echo "packages_json=$PACKAGES_JSON" >> $GITHUB_OUTPUT

      - name: Download, Verify, and Publish Extensions
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          CHROME_CLIENT_ID: ${{ secrets.CHROME_CLIENT_ID }}
          CHROME_CLIENT_SECRET: ${{ secrets.CHROME_CLIENT_SECRET }}
          CHROME_REFRESH_TOKEN: ${{ secrets.CHROME_REFRESH_TOKEN }}
          FIREFOX_API_KEY: ${{ secrets.FIREFOX_API_KEY }}
          FIREFOX_API_SECRET: ${{ secrets.FIREFOX_API_SECRET }}
        run: |
          echo '${{ steps.packages_to_publish.outputs.packages_json }}' | jq -c '.[]' | while read -r package; do
            PACKAGE_NAME=$(echo "$package" | jq -r .name)
            PACKAGE_VERSION=$(echo "$package" | jq -r .version)
            TAG_NAME="${PACKAGE_NAME}@${PACKAGE_VERSION}"
            ASSET_NAME="dist.zip"
            TEMP_DIR="publish_$(echo $PACKAGE_NAME | sed 's/@//g; s/\//-/g')" # Create a safe directory name

            echo ""
            echo "--- Processing package: ${TAG_NAME} ---"

            echo "Downloading release asset: ${ASSET_NAME} from ${TAG_NAME}"
            gh release download "$TAG_NAME" --pattern "$ASSET_NAME" --output "./${ASSET_NAME}"
            if [ $? -ne 0 ]; then
                echo "::warning::Could not download ${ASSET_NAME} for ${TAG_NAME}. It might not be an extension package. Skipping."
                continue
            fi

            mkdir -p "$TEMP_DIR"
            unzip -q "./${ASSET_NAME}" -d "$TEMP_DIR"
            rm "./${ASSET_NAME}"

            EXT_DIR="$TEMP_DIR/dist"

            if [ ! -f "${EXT_DIR}/extension-config.json" ]; then
              echo "::warning::No 'extension-config.json' found in the dist folder for ${TAG_NAME}. Skipping publish."
              rm -rf "$TEMP_DIR"
              continue
            fi

            echo "Found extension-config.json, preparing to publish."

            find "$EXT_DIR" -maxdepth 1 -type f -name '*-extension.zip' | while read -r zip_file; do
              browser_name=$(basename "$zip_file" -extension.zip)
              extension_id=$(jq -r ".$browser_name.extensionId" "${EXT_DIR}/extension-config.json")

              if [[ -z "$extension_id" || "$extension_id" == "null" ]]; then
                echo "::error::extensionId not found for $browser_name in extension-config.json"
                continue
              fi

              if [[ "$browser_name" == "firefox" ]]; then
                source_dir="$EXT_DIR/$browser_name"
                echo "Publishing $source_dir to Firefox Add-on Store..."
                # npx web-ext sign --source-dir "$source_dir" --api-key "$FIREFOX_API_KEY" --api-secret "$FIREFOX_API_SECRET" --id "$extension_id"
                echo "(Placeholder: Firefox publish command for $zip_file)"

              elif [[ "$browser_name" == "chrome" ]]; then
                echo "Publishing $zip_file to Chrome Web Store..."
                # npx chrome-webstore-upload-cli upload --source "$zip_file" --extension-id "$extension_id" --auto-publish
                echo "(Placeholder: Chrome publish command for $zip_file)"

              else
                echo "::warning::Unknown browser '$browser_name' from file '$zip_file'. Skipping."
              fi
            done

            echo "Publishing of ${TAG_NAME} completed."
            rm -rf "$TEMP_DIR"
            echo "Cleaned up temporary directory."
            echo "--- Finished: ${TAG_NAME} ---"
          done