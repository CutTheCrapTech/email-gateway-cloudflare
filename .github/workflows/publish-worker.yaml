# .github/workflows/publish-worker.yml
name: Deploy Workers

on:
  workflow_dispatch:
    inputs:
      package_name:
        description: "The scoped name of the worker package to deploy (e.g., '@email-gateway/cloudflare-worker'). Found in the package's package.json or from previous GitHub Release tags."
        required: true
        type: string
      environment:
        description: "Deployment environment"
        required: false
        default: "production"
        type: choice
        options:
          - production
          - staging
  workflow_call:
    inputs:
      published_packages:
        description: "JSON array of published packages from changesets/action"
        required: true
        type: string
      environment:
        description: "Deployment environment"
        required: false
        default: "production"
        type: string
    secrets:
      CLOUDFLARE_API_TOKEN:
        required: true
      CLOUDFLARE_ACCOUNT_ID:
        required: true

jobs:
  deploy-workers:
    runs-on: ubuntu-latest
    permissions:
      contents: read # To checkout the repo and read releases
    environment: ${{ inputs.environment || 'production' }}
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      - name: Install pnpm
        uses: pnpm/action-setup@a7487c7e89a18df4991f7f222e4898a00d66ddda # v4.1.0
        with:
          version: 10

      - name: Set up Node.js
        uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # v4.4.0
        with:
          node-version: "lts/*"
          cache: "pnpm"

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Determine Packages to Deploy
        id: packages_to_deploy
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PACKAGES_JSON="[]"
          # Manual workflow_dispatch run
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            PACKAGE_NAME="${{ inputs.package_name }}"
            echo "Manual run for package: $PACKAGE_NAME"
            LATEST_VERSION=$(gh release list --repo $GITHUB_REPOSITORY --limit 1 --json tagName --jq ".[] | select(.tagName | startswith(\"$PACKAGE_NAME@\")) | .tagName" | sed "s#$PACKAGE_NAME@##")
            if [ -z "$LATEST_VERSION" ]; then
              echo "::error::Could not find any releases for package $PACKAGE_NAME."
              exit 1
            fi
            echo "Found latest version: $LATEST_VERSION"
            # Fix: Use proper JSON construction with jq
            PACKAGES_JSON=$(jq -n \
              --arg name "$PACKAGE_NAME" \
              --arg version "$LATEST_VERSION" \
              '[{"name": $name, "version": $version}]')
          # Automated workflow_call run
          else
            echo "Automated run from published packages."
            PACKAGES_JSON='${{ inputs.published_packages }}'
          fi

          # Debug output
          echo "Generated packages JSON:"
          echo "$PACKAGES_JSON"

          # Write to GitHub output with proper escaping
          {
            echo "packages_json<<EOF"
            echo "$PACKAGES_JSON"
            echo "EOF"
          } >> $GITHUB_OUTPUT

      - name: Download, Verify, and Deploy Workers
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          PACKAGES_TO_PROCESS='${{ steps.packages_to_deploy.outputs.packages_json }}'
          echo "Processing packages: $PACKAGES_TO_PROCESS"

          echo "$PACKAGES_TO_PROCESS" | jq -c '.[]' | while read -r package; do
            PACKAGE_NAME=$(echo "$package" | jq -r .name)
            PACKAGE_VERSION=$(echo "$package" | jq -r .version)
            TAG_NAME="${PACKAGE_NAME}@${PACKAGE_VERSION}"
            TEMP_DIR="deploy_$(echo $PACKAGE_NAME | sed 's/@//g; s/\//-/g')" # Create a safe directory name

            echo ""
            echo "--- Processing package: ${TAG_NAME} ---"

            mkdir -p "$TEMP_DIR"

            ASSET_NAME="worker.js"
            echo "Downloading release asset: ${ASSET_NAME} from ${TAG_NAME}"
            gh release download "$TAG_NAME" --pattern "$ASSET_NAME" --output "$TEMP_DIR/$ASSET_NAME"
            if [ $? -ne 0 ]; then
                echo "::warning::Could not download ${ASSET_NAME} for ${TAG_NAME}. It might not be a worker package. Skipping."
                rm -rf "$TEMP_DIR"
                continue
            fi

            echo "Found worker.js, preparing to deploy."

            PACKAGE_DIR=""
            for dir in packages/*/; do
              if [ -f "${dir}package.json" ]; then
                name=$(jq -r .name "${dir}package.json")
                if [ "$name" == "$PACKAGE_NAME" ]; then
                  PACKAGE_DIR=$dir
                  break
                fi
              fi
            done

            if [ -z "$PACKAGE_DIR" ] || [ ! -f "${PACKAGE_DIR}wrangler.toml.template" ]; then
                echo "::error::Could not find wrangler.toml.template for package ${PACKAGE_NAME} in any of the package directories. Cannot deploy."
                rm -rf "$TEMP_DIR"
                continue
            fi

            cp "${PACKAGE_DIR}wrangler.toml.template" "$TEMP_DIR/wrangler.toml"

            # Generate a environment-specific worker name from the package name
            WORKER_NAME="$(echo $PACKAGE_NAME | sed 's/@//g; s/\//-/g')-${{ inputs.environment || 'production' }}"

            echo "Deploying worker: ${PACKAGE_NAME} v${PACKAGE_VERSION} as ${WORKER_NAME}"
            pnpm wrangler deploy --config "$TEMP_DIR/wrangler.toml" --env ${{ inputs.environment || 'production' }} --name "$WORKER_NAME"

            echo "Deployment of ${TAG_NAME} completed."
            rm -rf "$TEMP_DIR"
            echo "Cleaned up temporary directory."
            echo "--- Finished: ${TAG_NAME} ---"
          done
